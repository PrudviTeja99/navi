#!/bin/bash
# Navi - Omarchy-like interactive package manager for CachyOS
# Features: CamelCase fuzzy menus, sudo upfront, interactive/auto-confirm (-y/-n),
# CLI args, fuzzy package search with preview, and sleep inhibition during updates.

set -euo pipefail

# Load helper functions
DEP_SCRIPT_DIR="/usr/local/share/navi"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$DEP_SCRIPT_DIR/navi-ensure-source-installed.sh"
source "$DEP_SCRIPT_DIR/navi-colors.sh"
source "$DEP_SCRIPT_DIR/navi-fetch-packages.sh"
source "$DEP_SCRIPT_DIR/navi-cleanup.sh"

# --- Show help ---
show_help() {
    cat <<EOF
Navi - Interactive Package Manager Wrapper

Usage:
  navi [ACTION] [SOURCE] [OPTIONS]

Actions:
  install     Install packages
  remove      Remove installed packages
  update      Update all packages (pacman, AUR, Flatpak)

Sources:
  pacman      Use pacman for official repo packages
  paru        Use paru for AUR packages

Options:
  -y, --yes     Auto-confirm all prompts (assume "yes")
  -n, --no      Auto-decline all prompts (assume "no")
  --dry-run     Show what would be done without executing
  -h, --help    Show this help message and exit

Examples:
  navi                # Start interactive fuzzy menu
  navi install pacman # Install package(s) from official repos
  navi remove paru    # Remove package(s) installed via AUR
  navi update -y      # Update everything without prompts

Notes:
  * If no ACTION or SOURCE is provided, fuzzy menus will guide you.
  * Package descriptions are shown in preview with Ctrl-P toggle.
  * Updates run under systemd-inhibit to prevent sleep/idle.
EOF
    exit 0
}

# --- Parse help ---
for arg in "$@"; do
    case "$arg" in
        -h|--help) show_help ;;
    esac
done

# --- Sudo upfront & keep alive ---
sudo -v
while true; do sudo -v; sleep 60; done 2>/dev/null &
SUDO_LOOP_PID=$!
trap "kill $SUDO_LOOP_PID" EXIT INT TERM

# --- Check dependencies ---
for cmd in fzf pacman; do
    if ! command -v "$cmd" &>/dev/null; then
        echo "Error: $cmd is required but not installed."
        exit 1
    fi
done

HAS_PACMAN=false
HAS_FLATPAK=false
HAS_PARU=false
command -v pacman &>/dev/null && HAS_PACMAN=true
command -v flatpak &>/dev/null && HAS_FLATPAK=true
command -v paru &>/dev/null && HAS_PARU=true

PACMAN_INSTALLED_PID=""
AUR_INSTALLED_PID=""
FLATPAK_INSTALLED_PID=""

PACMAN_REMOTE_PID=""
AUR_REMOTE_PID=""
FLATPAK_REMOTE_PID=""

PACMAN_UPDATE_PID=""
AUR_UPDATE_PID=""
FLATPAK_UPDATE_PID=""

PACMAN_INSTALLED_TMP="/tmp/navi_pacman_installed"
AUR_INSTALLED_TMP="/tmp/navi_aur_installed"
FLATPAK_INSTALLED_TMP="/tmp/navi_flatpak_installed"

PACMAN_REMOTE_TMP="/tmp/navi_pacman_remote"
AUR_REMOTE_TMP="/tmp/navi_aur_remote"
FLATPAK_REMOTE_TMP="/tmp/navi_flatpak_remote"

PACMAN_UPDATE_TMP="/tmp/navi_pacman_update"
AUR_UPDATE_TMP="/tmp/navi_aur_update"
FLATPAK_UPDATE_TMP="/tmp/navi_flatpak_update"



# --- Parse options ---
AUTO_CONFIRM="ask" # default interactive
DRY_RUN=false
for arg in "$@"; do
    case "$arg" in
        -y|--yes) AUTO_CONFIRM="yes" ;;
        -n|--no)  AUTO_CONFIRM="no" ;;
        --dry-run) DRY_RUN=true ;;
    esac
done

# --- Determine action ---
action_input="${1:-}"

case "$action_input" in
    i) action="install" ;;
    r) action="remove" ;;
    u) action="update" ;;
    install|remove|update) action="$action_input" ;;
    "") 
        # Map display -> internal action
        mapfile -t ACTIONS < <(printf "Install:install\nRemove:remove\nSystem Update:update")
        
        # Show fzf menu
        action_display=$(printf "%s\n" "${ACTIONS[@]}" | cut -d':' -f1 | fzf --height=40% --reverse --border --prompt="Select action: " --ansi)
        
        # If nothing selected, default to Install
        [[ -z "$action_display" ]] && action_display="Install"
        
        # Map back to internal action
        action=$(printf "%s\n" "${ACTIONS[@]}" | grep "^$action_display:" | cut -d':' -f2)
        ;;
    *)
        echo "Unknown action: $action_input"
        exit 1
        ;;
esac

# Optional: make first letter uppercase for display
action_display="$(tr '[:lower:]' '[:upper:]' <<< ${action:0:1})${action:1}"


# --- Determine source (skip for update) ---
if [[ "$action" != "update" ]]; then

    #Initial packages fetch from remote and query from local
    fetch_all_packages

    source_input="${2:-}"
    case "$source_input" in
        p) source="pacman" ;;
        a) source="paru" ;;
        f) source="flatpak" ;;
        pacman|paru|flatpak) source="$source_input" ;;
        "")
            mapfile -t SOURCES < <(printf "Pacman (System):pacman\nParu (AUR Helper):paru\nFlatpak:flatpak")
            # Interactive menu
            source_display=$(printf "%s\n" "${SOURCES[@]}" | cut -d':' -f1 | fzf --height=20% --reverse --border --prompt="Select source: " --ansi)

            [[ -z "$source_display" ]] && source_display="Pacman"
            
            source=$(printf "%s\n" "${SOURCES[@]}" | grep "^$source_display:" | cut -d':' -f2)
            ;;
        *)
            echo "Unknown source: $source_input"
            exit 1
            ;;
    esac

    ensure_source_installed "$source"
    source_display="$(tr '[:lower:]' '[:upper:]' <<< ${source:0:1})${source:1}"
fi

run_inhibited() {
    local op="$1"
    local pkgs="$2"
    shift 2
    systemd-inhibit \
        --what=handle-lid-switch:sleep:idle \
        --who="navi script" \
        --why="Package $op: $pkgs" \
        bash -c "$*"
}


# --- Helper for package operations (install/remove) ---
pkg_action() {
    local op="$1"  # install/remove
    local pkgs="$2"

    pkgs=$(echo "$pkgs" | xargs) # trim
    [[ -z "$pkgs" ]] && return

    local yes_cmd=""
    local no_cmd=""

    if [[ "$op" == "install" ]]; then
        case "$source" in
            pacman)
                yes_cmd="sudo pacman -S --noconfirm $pkgs"
                no_cmd="echo n | sudo pacman -S $pkgs"
                ;;
            paru)
                yes_cmd="paru -S --noconfirm $pkgs"
                no_cmd="echo n | paru -S $pkgs"
                ;;
            flatpak)
                yes_cmd="flatpak install -y $pkgs"
                no_cmd="echo n | flatpak install $pkgs"
                ;;

        esac
    else  # remove
        case "$source" in
            pacman) 
                yes_cmd="sudo pacman -Rns --noconfirm $pkgs"
                no_cmd="echo n | sudo pacman -Rns $pkgs"
                ;;
            paru)   
                yes_cmd="paru -Rns --noconfirm $pkgs"
                no_cmd="echo n | paru -Rns $pkgs"
                ;;
            flatpak)
                yes_cmd="flatpak uninstall --delete-data -y $pkgs"
                no_cmd="echo n | flatpak uninstall $pkgs"
                ;;

        esac
    fi

    set +e
    # Apply confirm / dry-run logic
    if [[ "$AUTO_CONFIRM" == "yes" ]]; then
        run_inhibited "$op" "$pkgs" "$yes_cmd"
        greenLog "Done $op : $pkgs"
    elif [[ "$AUTO_CONFIRM" == "no" ]]; then
        run_inhibited "$op" "$pkgs" "$no_cmd"
        yellowLog "Skipping $op: $pkgs"
    else
        read -rp "$op $pkgs? [y/N]: " ans < /dev/tty
        if [[ "$ans" =~ ^[Yy]$ ]]; then
            run_inhibited "$op" "$pkgs" "$yes_cmd"
            greenLog "Done $op : $pkgs"
        else
            run_inhibited "$op" "$pkgs" "$no_cmd"
            yellowLog "Skipping $op: $pkgs"
        fi
    fi

    run_post_cleanup "$PACMAN_INSTALLED_TMP" "$AUR_INSTALLED_TMP" "$FLATPAK_INSTALLED_TMP" \
    "$PACMAN_REMOTE_TMP" "$AUR_REMOTE_TMP" "$FLATPAK_REMOTE_TMP"

    set -e
}

update_all() {

    greenLog "--- Updating Pacman Packages ---"
    $pacman_cmd

    if $HAS_PARU; then
        greenLog "--- Updating AUR Packages ---"
        $paru_cmd
    fi

    if $HAS_FLATPAK; then
        greenLog "--- Updating Flatpak Packages ---"
        $flatpak_cmd
    fi

    greenLog "All updates completed"

}

# --- Update packages ---
update_packages() {
    set +e

    # Initialize variables
    pacman_updates=""
    aur_updates=""
    flatpak_updates=""

    # --- Run in parallel ---
    checkupdates 2>/dev/null | awk '{print $1}' > "$PACMAN_UPDATE_TMP" &
    PACMAN_UPDATE_PID=$!

    if $HAS_PARU; then
        paru -Qua 2>/dev/null | sed 's/^ *//' | sed 's/ \+/ /g' | grep -vw "\[ignored\]$" | awk '{print $1}' > "$AUR_UPDATE_TMP" &
        AUR_UPDATE_PID=$!
    fi

    if $HAS_FLATPAK; then
        flatpak update | sed -n '/^ 1./,$p' | awk '{print $2}' | grep -v '^$' | sed '$d' > "$FLATPAK_UPDATE_TMP" &
        FLATPAK_UPDATE_PID=$!
    fi

    # Wait for all
    wait $PACMAN_UPDATE_PID
    [[ $HAS_PARU == true ]] && wait $AUR_UPDATE_PID
    [[ $HAS_FLATPAK == true ]] && wait $FLATPAK_UPDATE_PID

    # Read results
    pacman_updates=$(< "$PACMAN_UPDATE_TMP")
    [[ $HAS_PARU == true ]] && aur_updates=$(< "$AUR_UPDATE_TMP")
    [[ $HAS_FLATPAK == true ]] && flatpak_updates=$(< "$FLATPAK_UPDATE_TMP")

    # Clean temp files
    run_post_cleanup "$PACMAN_UPDATE_TMP" "$AUR_UPDATE_TMP" "$FLATPAK_UPDATE_TMP"

    set -e

    # Combine for preview
    updates_preview=""
    [[ -n "$pacman_updates" ]] && updates_preview+="\n${GREEN}--- Pacman Updates ---${RESET}\n$pacman_updates"
    [[ -n "$aur_updates" ]] && updates_preview+="\n${GREEN}--- AUR Updates ---${RESET}\n$aur_updates"
    [[ -n "$flatpak_updates" ]] && updates_preview+="\n${GREEN}--- Flatpak Updates ---${RESET}\n$flatpak_updates"

    if [[ -z "$updates_preview" ]]; then
        greenLog "All packages are up-to-date"
        return
    fi

    # Show preview
    echo -e "$updates_preview"

    # Ask user to proceed if AUTO_CONFIRM=ask
    if [[ "$AUTO_CONFIRM" == "ask" ]]; then
        read -rp $'\nProceed with updating all packages? [y/N]: ' ans < /dev/tty
        [[ ! "$ans" =~ ^[Yy]$ ]] && { echo -e "${YELLOW}Skipping all updates.${RESET}"; return; }
    elif [[ "$AUTO_CONFIRM" == "no" ]]; then
        yellowLog "Skipping all updates"; return;
    fi

    yellowLog "Updating packages (sleep/idle inhibited)..."
    pacman_cmd="sudo pacman -Syu --noconfirm"
    paru_cmd="paru -Sua --noconfirm"
    flatpak_cmd="flatpak update -y"

    export pacman_cmd paru_cmd flatpak_cmd

    export GREEN YELLOW RED RESET

    run_inhibited "update" "all" "$(declare -f update_all); update_all"
    
}

# --- Run update directly ---
if [[ "$action" == "update" ]]; then
    update_packages
    exit 0
fi

# --- Build package list ---
if [[ "$action" == "remove" ]]; then
    case "$source" in
        pacman) 
            wait $PACMAN_INSTALLED_PID
            pkg_list=$(< /tmp/navi_pacman_installed) ;;
        paru)   
            wait $AUR_INSTALLED_PID
            pkg_list=$(< /tmp/navi_aur_installed) ;;
        flatpak) 
            wait $FLATPAK_INSTALLED_PID
            pkg_list=$(< /tmp/navi_flatpak_installed) ;;
    esac
else
    case "$source" in
        pacman) 
            wait $PACMAN_REMOTE_PID
            pkg_list=$(< /tmp/navi_pacman_remote) ;;
        paru)
            wait $AUR_REMOTE_PID
            pkg_list=$(< /tmp/navi_aur_remote) ;;
        flatpak)
            wait $FLATPAK_REMOTE_PID
            pkg_list=$(< /tmp/navi_flatpak_remote) ;;  # simple search for all
    esac
fi

# --- Fuzzy select packages ---
pkg=$(echo "$pkg_list" | fzf \
    --multi \
    --height=100% \
    --layout=reverse \
    --border \
    --prompt="[$source_display] $action_display: " \
    --preview "if [[ '$source' == 'pacman' ]]; then
              pacman -Si {};
          elif [[ '$source' == 'paru' ]]; then
              paru -Si {};
          else
            flatpak info {} 2>/dev/null || flatpak remote-info flathub {}
          fi" \
    --bind "ctrl-p:toggle-preview"
)

[[ -z "$pkg" ]] && { echo "No package selected."; exit 0; }

selected_pkgs=$(echo "$pkg" | tr '\n' ' ')

# --- Perform selected action ---
pkg_action "$action" "$selected_pkgs"
